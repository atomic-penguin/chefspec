{"name":"ChefSpec","tagline":"Write RSpec examples for Opscode Chef cookbooks","body":"ChefSpec\r\n========\r\n[![Built on Travis](https://secure.travis-ci.org/sethvargo/chefspec.png?branch=master)](http://travis-ci.org/sethvargo/chefspec)\r\n[![Gem Version](https://badge.fury.io/rb/chefspec.png)](http://badge.fury.io/rb/chefspec)\r\n[![Dependency Status](https://gemnasium.com/sethvargo/chefspec.png)](https://gemnasium.com/sethvargo/chefspec)\r\n[![Code Climate](https://codeclimate.com/github/sethvargo/chefspec.png)](https://codeclimate.com/github/sethvargo/chefspec)\r\n\r\nChefSpec is a unit testing framework for testing Chef cookbooks. ChefSpec makes it easy to write examples and get fast feedback on cookbook changes without the need for virtual machines or cloud servers.\r\n\r\nChefSpec runs your cookbook locally using Chef Solo without actually converging a node. This has two primary benefits:\r\n\r\n- It's really fast!\r\n- Your tests can vary node attributes, operating systems, and search results to assert behavior under varying conditions.\r\n\r\n\r\nWhat people are saying\r\n----------------------\r\n> I just wanted to drop you a line to say \"HELL YES!\" to ChefSpec. - [Joe Goggins](https://twitter.com/jgoggins)\r\n\r\n> OK chefspec is my new best friend. Delightful few hours working with it. - [Michael Ivey](https://twitter.com/ivey)\r\n\r\n**Chat with us - [#chefspec](irc://irc.freenode.net/chefspec) on Freenode**\r\n\r\n\r\nImportant Notes\r\n---------------\r\n- **ChefSpec 3 requires Chef 11+! Please use the 2.x series for Chef 9 & 10 compatibility.**\r\n- **This documentation corresponds to the master branch, which may be unreleased. Please check the README of the latest git tag or the gem's source for your version' documentation!**\r\n- **Each resource matcher is self-documented using [Yard](http://rubydoc.info/github/sethvargo/chefspec) and has a corresponding aruba test from the [examples directory](https://github.com/sethvargo/chefspec/tree/master/examples).**\r\n- **ChefSpec 3.0 requires Ruby 1.9 or higher!**\r\n\r\nIf you are migrating from ChefSpec v2.0.0, you should require the deprecations module after requiring `chefspec`:\r\n\r\n```ruby\r\n# spec_helper.rb\r\nrequire 'chefspec'\r\nrequire 'chefspec/deprecations'\r\n```\r\n\r\nAfter you have converted your specs, you can safely remove the deprecations module.\r\n\r\n\r\nWriting a Cookbook Example\r\n--------------------------\r\nIf you want `knife` to automatically generate spec stubs for you, install [knife-spec](https://github.com/sethvargo/knife-spec).\r\n\r\nGiven an extremely basic Chef recipe that just installs an operating system package:\r\n\r\n```ruby\r\npackage 'foo'\r\n```\r\n\r\nthe associated ChefSpec test might look like:\r\n\r\n```ruby\r\nrequire 'chefspec'\r\n\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new.converge(described_recipe) }\r\n\r\n  it 'installs foo' do\r\n    expect(chef_run).to install_package('foo')\r\n  end\r\nend\r\n```\r\n\r\nLet's step through this file to see what is happening:\r\n\r\n1. At the top of the spec file we require the chefspec gem. This is required so that our custom matchers are loaded. In larger projects, it is common practice to create a file named \"spec_helper.rb\" and include ChefSpec and perform other setup tasks in that file.\r\n1. The `describe` keyword is part of RSpec and indicates that everything nested beneath is describing the `example::default` recipe. The convention is to have a separate spec for each recipe in your cookbook.\r\n1. The `let` block on creates the `ChefSpec:Runner` and then does a fake Chef run with the run_list of `example::default`. Any subsequent examples can then refer to `chef_run` in order to make assertions about the resources that were created during the mock converge.\r\n1. The `described_recipe` macro is a ChefSpec helper method that infers the recipe from the `describe` block. Alternatively you could specify the recipe directly.\r\n1. The `it` block is an example specifying that the `foo` package is installed. Normally you will have multiple `it` blocks per recipe, each making a single assertion.\r\n\r\n\r\nConfiguration\r\n-------------\r\nChefSpec exposes a configuration layer at the global level and at the `Runner` level. The following settings are available:\r\n\r\n```ruby\r\nRSpec.configure do |config|\r\n  # Specify the path for Chef Solo to find cookbooks (default: [inferred from\r\n  # the location of the calling spec file])\r\n  config.cookbook_path = '/var/cookbooks'\r\n\r\n  # Specify the path for Chef Solo to find roles (default: [ascending search])\r\n  config.role_path = '/var/roles'\r\n\r\n  # Specify the Chef log_level (default: :warn)\r\n  config.log_level = :debug\r\n\r\n  # Specify the path to a local JSON file with Ohai data (default: nil)\r\n  config.path = 'ohai.json'\r\n\r\n  # Specify the operating platform to mock Ohai data from (default: nil)\r\n  config.platform = 'ubuntu'\r\n\r\n  # Specify the operating version to mock Ohai data from (default: nil)\r\n  config.version = '12.04'\r\nend\r\n```\r\n\r\nValues specified at the initialization of the `Runner` merge and take precedence over the global settings:\r\n\r\n```ruby\r\n# Override only the operating system version (platform is still \"ubuntu\" from above)\r\nChefSpec::Runner.new(version: '10.04')\r\n\r\n# Use a different operating system platform and version\r\nChefSpec::Runner.new(platform: 'centos', version: '5.4')\r\n\r\n# Specify a different cookbook_path\r\nChefSpec::Runner.new(cookbook_path: '/var/my/other/path', role_path: '/var/my/roles')\r\n\r\n# Add debug log output\r\nChefSpec::Runner.new(log_level: :debug).converge(described_recipe)\r\n```\r\n\r\n**NOTE** You do not _need_ to specify a platform and version. However, some cookbooks may rely on [Ohai](http://github.com/opscode/ohai) data that ChefSpec cannot not automatically generate. Specifying the `platform` and `version` keys instructs ChefSpec to load stubbed Ohai attributes from another platform using [fauxhai](https://github.com/customink/fauxhai).\r\n\r\n### Berkshelf\r\nIf you are using Berkshelf, simply require `chefspec/berkshelf` in your `spec_helper` after requiring `chefspec`:\r\n\r\n```ruby\r\n# spec_helper.rb\r\nrequire 'chefspec'\r\nrequire 'chefspec/berkshelf'\r\n```\r\n\r\nRequiring this file will:\r\n\r\n- Create a temporary working directory\r\n- Download all the dependencies listed in your `Berksfile` into the temporary directory\r\n- Set ChefSpec's `cookbook_path` to the temporary directory\r\n\r\n### Librarian\r\n\r\nIf you are using Librarian, simply require `chefspec/librarian` in your `spec_helper` after requiring `chefspec`:\r\n\r\n```ruby\r\n# spec_helper.rb\r\nrequire 'chefspec'\r\nrequire 'chefspec/librarian'\r\n```\r\n\r\nRequiring this file will:\r\n\r\n- Create a temporary working directory\r\n- Download all the dependencies listed in your `Cheffile` into the temporary directory\r\n- Set ChefSpec's `cookbook_path` to the temporary directory\r\n\r\n**NOTE** In order to test the cookbook in the current working directory, you\r\nhave to write your `Cheffile` like this:\r\n\r\n```ruby\r\n# Cheffile\r\nsite 'http://community.opscode.com/api/v1'\r\n\r\ncookbook 'name_of_your_cookbook', path: '.'\r\n```\r\n\r\n\r\nRunning Specs\r\n-------------\r\nChefSpec is actually a very large RSpec extension, so you can run your tests using the RSpec CLI:\r\n\r\n```bash\r\n$ rspec\r\n```\r\n\r\nYou can also specify a specific spec to run and various RSpec command line options:\r\n\r\n```bash\r\n$ rspec spec/unit/recipes/default_spec.rb --color\r\n```\r\n\r\nFor more information on the RSpec CLI, please see the [documentation](https://relishapp.com/rspec/rspec-core/docs/command-line).\r\n\r\n\r\nMaking Assertions\r\n-----------------\r\nChefSpec asserts that resource actions have been performed. In general, ChefSpec follows the following pattern:\r\n\r\n```ruby\r\nrequire 'chefspec'\r\n\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new.converge(described_recipe) }\r\n\r\n  it 'does something' do\r\n    expect(chef_run).to ACTION_RESOURCE(NAME)\r\n  end\r\nend\r\n```\r\n\r\nwhere:\r\n\r\n- _ACTION_ - the action on the resource (e.g. `install`)\r\n- _RESOURCE_ - the name of the resource (e.g. `package`)\r\n- _NAME_ - the name attribute for the resource (e.g. `apache2`)\r\n\r\nHere's a more concrete example:\r\n\r\n```ruby\r\nrequire 'chefspec'\r\n\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new.converge(described_recipe) }\r\n\r\n  it 'does something' do\r\n    expect(chef_run).to install_package('apache2')\r\n  end\r\nend\r\n```\r\n\r\nThis test is asserting that the Chef run will have a _package_ resource with the name _apache2_ with an action of _install_.\r\n\r\nTo test that a resource action is performed with a specific set of attributes, you can call `with(ATTRIBUTES_HASH)` on the expectation, per the following example:\r\n\r\n```ruby\r\nrequire 'chefspec'\r\n\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new.converge(described_recipe) }\r\n\r\n  it 'does something' do\r\n    expect(chef_run).to modify_group('docker').with(members: ['vagrant'])\r\n  end\r\nend\r\n```\r\n\r\nThis test is asserting that the Chef run will have a _group_ resource with the name _docker_, an action of _modify_, and an attributes hash including `{ members: ['vagrant'] }`.\r\n\r\nChefSpec includes matchers for all of Chef's core resources using the above schema. Each resource matcher is self-documented using [Yard](http://rubydoc.info/github/sethvargo/chefspec) and has a corresponding cucumber test from the [examples directory](https://github.com/sethvargo/chefspec/tree/master/examples).\r\n\r\nAdditionally, ChefSpec includes the following helpful matchers. They are also [documented in Yard](http://rubydoc.info/github/sethvargo/chefspec), but they are included here because they do not follow the \"general pattern\".\r\n\r\n##### include_recipe\r\nAssert that the Chef run included a recipe from another cookbook\r\n\r\n```ruby\r\nexpect(chef_run).to include_recipe('other_cookbook::recipe')\r\n```\r\n\r\n##### notify\r\nAssert that a resource notifies another in the Chef run\r\n\r\n```ruby\r\nresource = chef_run.template('/etc/foo')\r\nexpect(resource).to notify('service[apache2]').to(:restart).immediately\r\n```\r\n\r\n##### subscribes\r\nAssert that a resource subscribes to another in the Chef run\r\n\r\n```ruby\r\nresource = chef_run.service('apache2')\r\nexpect(resource).to subscribe_to('template[/etc/foo]').on(:create).delayed\r\n```\r\n\r\n##### render_file\r\nAssert that the Chef run renders a file (with optional content); this will match `cookbook_file`, `file`, and `template` resources and can also check the resulting content\r\n\r\n```ruby\r\nexpect(chef_run).to render_file('/etc/foo')\r\nexpect(chef_run).to render_file('/etc/foo').with_content('This is content')\r\nexpect(chef_run).to render_file('/etc/foo').with_content(/regex works too.+/)\r\n```\r\n\r\nAdditionally, it is possible to assert which [Chef phase of execution](http://docs.opscode.com/essentials_nodes_chef_run.html) a resource is created. Given a resource that is installed at compile time using `run_action`:\r\n\r\n```ruby\r\npackage('apache2').run_action(:install)\r\n```\r\n\r\nYou can assert that this package is installed during runtime using the `.at_compile_time` predicate on the resource matcher:\r\n\r\n```ruby\r\nexpect(chef_run).to install_package('apache2').at_compile_time\r\n```\r\n\r\nSimilarly, you can assert that a resource is executed during convergence time:\r\n\r\n```ruby\r\nexpect(chef_run).to install_package('apache2').at_converge_time\r\n```\r\n\r\nSince \"converge time\" is the default behavior for all recipes, this test might be redundant and the predicate could be dropped depending on your situation.\r\n\r\n**For more complex examples, please see the [examples directory](https://github.com/sethvargo/chefspec/tree/master/examples) or the [Yard documentation](http://rubydoc.info/github/sethvargo/chefspec).**\r\n\r\n\r\nSetting node Attributes\r\n-----------------------\r\nNode attribute can be set when creating the `Runner`. The initializer yields a block that gives full access to the node object:\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) do\r\n    ChefSpec::Runner.new do |node|\r\n      node.set['cookbook']['attribute'] = 'hello'\r\n    end.converge(described_recipe)\r\n  end\r\nend\r\n```\r\n\r\n### Automatic attributes\r\nChefSpec provides mocked automatic Ohai data using [fauxhai](https://github.com/customink/fauxhai). To mock out `automatic` attributes, you must use the `automatic` key:\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) do\r\n    ChefSpec::Runner.new do |node|\r\n      node.automatic['memory']['total'] = '512kB'\r\n    end.converge(described_recipe)\r\n  end\r\nend\r\n```\r\n\r\nThe `node` that is returned is actually a [`Chef::Node`](http://docs.opscode.com/essentials_node_object.html) object.\r\n\r\nTo set an attribute within a specific test, set the attribute in the `it` block and then **(re-)converge the node**:\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new } # Notice we don't converge here\r\n\r\n  it 'performs the action' do\r\n    chef_run.node.set['cookbook']['attribute'] = 'hello'\r\n    chef_run.converge(described_recipe) # The converge happens inside the test\r\n\r\n    expect(chef_run).to do_something\r\n  end\r\nend\r\n```\r\n\r\nUsing Chef Zero\r\n---------------\r\nBy default, ChefSpec runs in Chef Solo mode. As of ChefSpec v3.1.0, you can ask ChefSpec to create an in-memory Chef Server during testing using [ChefZero](https://github.com/jkeiser/chef-zero). This is especially helpful if you need to support searching or data bags.\r\n\r\nTo use the ChefSpec server, simply require the module in your `spec_helper`:\r\n\r\n```ruby\r\n# spec_helper.rb\r\nrequire 'chefspec'\r\nrequire 'chefspec/server'\r\n```\r\n\r\nThis will automatically create a Chef server, synchronize all the cookbooks in your `cookbook_path`, and wire all the internals of Chef together. Recipe calls to `search`, `data_bag` and `data_bag_item` will now query the ChefSpec server.\r\n\r\n### DSL\r\nThe ChefSpec server includes a collection of helpful DSL methods for populating data into the Chef Server.\r\n\r\nCreate a client:\r\n\r\n```ruby\r\nChefSpec::Server.create_client('my_client', { admin: true })\r\n```\r\n\r\nCreate a data bag (and items):\r\n\r\n```ruby\r\nChefSpec::Server.create_data_bag('my_data_bag', {\r\n  'item_1' => {\r\n    'password' => 'abc123'\r\n  },\r\n  'item_2' => {\r\n    'password' => 'def456'\r\n  }\r\n})\r\n```\r\n\r\nCreate an environment:\r\n\r\n```ruby\r\nChefSpec::Server.create_environment('my_environment', { description: '...' })\r\n```\r\n\r\nCreate a node:\r\n\r\n```ruby\r\nChefSpec::Server.create_node('my_node', { run_list: ['...'] })\r\n```\r\n\r\nYou may also be interested in the `stub_node` macro, which will create a new `Chef::Node` object and accepts the same parameters as the Chef Runner and a Fauxhai object:\r\n\r\n```ruby\r\nwww = stub_node(platform: 'ubuntu', version: '12.04') do |node|\r\n        node.set['attribute'] = 'value'\r\n      end\r\n\r\n# `www` is now a local Chef::Node object you can use in your test. To push this\r\n# node to the server, call `create_node`:\r\n\r\nChefSpec::Server.create_node(www)\r\n```\r\n\r\nCreate a role:\r\n\r\n```ruby\r\nChefSpec::Server.create_role('my_role', { default_attributes: {} })\r\n\r\n# The role now exists on the Chef Server, you can add it to a node's run_list\r\n# by adding it to the `converge` block:\r\nlet(:chef_run) { ChefSpec::Runner.new.converge(described_recipe, 'role[my_role]') }\r\n```\r\n\r\n**NOTE** The ChefSpec server is empty at the start of each example to avoid interdependent tests. You can use `before` blocks to load data before each test.\r\n\r\n\r\nStubbing\r\n--------\r\n### Command\r\nGiven a recipe with shell guard:\r\n\r\n```ruby\r\ntemplate '/tmp/foo.txt' do\r\n  not_if 'grep /tmp/foo.txt text'\r\nend\r\n```\r\n\r\nChefSpec will raise an error like:\r\n\r\n```text\r\nReal commands are disabled. Unregistered command: `grep /tmp/foo.txt text`\r\n\r\nYou can stub this command with:\r\n\r\n stub_command(\"grep /tmp/foo.txt text\").and_return(true)\r\n\r\n============================================================\r\n```\r\n\r\nJust like the error message says, you must stub the command result. This can be done inside a `before` block or inside the `it` block, and the stubbing method accepts both a value or Ruby code. If provided a value, the result is static. If provided a Ruby block, the block is evaluated each time the search is called.\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new }\r\n\r\n  before do\r\n    stub_command(\"grep /tmp/foo.txt text\").and_return(true)\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new }\r\n\r\n  before do\r\n    stub_command(\"grep /tmp/foo.txt text\") { rand(50)%2 == 0 }\r\n  end\r\nend\r\n```\r\n\r\n### Data Bag & Data Bag Item\r\n**NOTE** This is not required if you are using a ChefSpec server.\r\n\r\nGiven a recipe that executes a `data_bag` method:\r\n\r\n```ruby\r\ndata_bag('users').each do |user|\r\n  data_bag_item('users', user['id'])\r\nend\r\n```\r\n\r\nChefSpec will rails an error like:\r\n\r\n```text\r\nReal data_bags are disabled. Unregistered data_bag: data_bag(:users)\r\n\r\nYou can stub this data_bag with:\r\n\r\n  stub_data_bag(\"users\").and_return([])\r\n\r\n============================================================\r\n```\r\n\r\nJust like the error message says, you must stub the result of the `data_bag` call. This can be done inside a `before` block or inside the `it` block, and the stubbing method accepts both a value or Ruby code. If provided a value, the result is static. If provided a Ruby block, the block is evaluated each time the search is called.\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new }\r\n\r\n  before do\r\n    stub_data_bag('users').and_return([])\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new }\r\n\r\n  before do\r\n    stub_data_bag('users').and_return(['svargo', 'francis'])\r\n\r\n    stub_data_bag_item('users', 'svargo').and_return({ ... })\r\n    stub_data_bag_item('users', 'francis') { (ruby code) }\r\n  end\r\nend\r\n```\r\n\r\nIf you are using **Encrypted Data Bag Items**, you'll need to dive into the RSpec layer and stub that class method instead:\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  before do\r\n    Chef::EncryptedDataBagItem.stub(:load).with('users', 'svargo').and_return(...)\r\n  end\r\nend\r\n```\r\n\r\n### Search\r\n**NOTE** This is not required if you are using a ChefSpec server.\r\n\r\nBecause ChefSpec is a unit-testing framework, it is recommended that all third-party API calls be mocked or stubbed. ChefSpec exposes a helpful RSpec macro for stubbing search results in your tests. If you converge a Chef recipe that implements a `search` call, ChefSpec will throw an error like:\r\n\r\n```text\r\nReal searches are disabled. Unregistered search: search(:node, 'name:hello')\r\n\r\nYou can stub this search with:\r\n\r\n  stub_search(:node, 'name:hello') {  }\r\n\r\n============================================================\r\n```\r\n\r\nJust like the error message says, you must stub the search result. This can be done inside a `before` block or inside the `it` block, and the stubbing method accepts both a value or Ruby code. If provided a value, the result is static. If provided a Ruby block, the block is evaluated each time the search is called.\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new }\r\n\r\n  before do\r\n    stub_search(:node, 'name:hello').and_return([])\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\ndescribe 'example::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new }\r\n\r\n  before do\r\n    stub_search(:node, 'name:hello') { (ruby_code) }\r\n  end\r\nend\r\n```\r\n\r\nReporting\r\n---------\r\nChefSpec can generate a report of resources read over resources tested. Please note, this feature is currently in beta phases and may not be 100% accurate. That being said, it is currently the only code coverage tool available for Chef recipes.\r\n\r\nTo generate the coverage report, add the following to your `spec_helper.rb` before you require any \"Chef\" code:\r\n\r\n```ruby\r\nrequire 'chefspec'\r\nChefSpec::Coverage.start!\r\n\r\n# Existing spec_helper contents...\r\n```\r\n\r\nBy default, that method will output helpful information to standard out:\r\n\r\n```text\r\nChefSpec Coverage report generated at '.coverage/results.json':\r\n\r\n  Total Resources:   6\r\n  Touched Resources: 1\r\n  Touch Coverage:    16.67%\r\n\r\nUntouched Resources:\r\n\r\n  package[git]               bacon/recipes/default.rb:2\r\n  package[build-essential]   bacon/recipes/default.rb:3\r\n  package[apache2]           bacon/recipes/default.rb:4\r\n  package[libvrt]            bacon/recipes/default.rb:5\r\n  package[core]              bacon/recipes/default.rb:6\r\n```\r\n\r\nBy default, ChefSpec will test all cookbooks that are loaded as part of the Chef Client run. If you have a cookbook with many dependencies, this may be less than desireable. To restrict coverage reporting against certain cookbooks, `ChefSpec::Coverage` yields a block:\r\n\r\n```ruby\r\nChefSpec::Coverage.start! do\r\n  add_filter 'vendor/cookbooks'\r\nend\r\n```\r\n\r\nThe `add_filter` method accepts a variety of objects. For example:\r\n\r\n```ruby\r\nChefSpec::Coverage.start! do\r\n  # Strings are interpreted as file paths, with a forward anchor\r\n  add_filter 'vendor/cookbooks'\r\n\r\n  # Regular expressions must be escaped, but provide a nicer API for negative\r\n  # back tracking\r\n  add_filter /cookbooks\\/(?!omnibus)/\r\n\r\n  # Custom block filters yield a {Chef::Resource} object - if the block\r\n  # evaluates to true, it will be filtered\r\n  add_filter do |resource|\r\n    # Bob's cookbook's are completely untested! Ignore them until he gets his\r\n    # shit together.\r\n    resource.source_file =~ /cookbooks\\/bob-(.+)/\r\n  end\r\nend\r\n```\r\n\r\nFor more complex scenarios, you can create a custom `Filter` object that inherits from `ChefSpec::Coverage::Filter` and implements the `matches?` method.\r\n\r\n```ruby\r\nclass CustomFilter < ChefSpec::Coverage::Filter\r\n  def initialize(arg1, arg2, &block)\r\n    # Create a custom initialization method, do some magic, etc.\r\n  end\r\n\r\n  def matches?(resource)\r\n    # Custom matching logic in here - anything that evaluates to \"true\" will be\r\n    # filtered.\r\n  end\r\nend\r\n\r\nChefSpec::Converage.start! do\r\n  add_filter CustomFilter.new('foo', :bar)\r\nend\r\n```\r\n\r\nIf you are using ChefSpec's Berkshelf plugin, a filter is automatically created for you. If you would like to ignore that filter, you can `clear` all the filters before defining your own:\r\n\r\n```ruby\r\nChefSpec::Coverage.start! do\r\n  filters.clear\r\n\r\n  # Add your custom filters now\r\nend\r\n```\r\n\r\n\r\nMocking Out Environments\r\n------------------------\r\nIf you want to mock out `node.chef_environment`, you'll need to use RSpec mocks/stubs twice:\r\n\r\n```ruby\r\nlet(:chef_run) do\r\n  ChefSpec::Runner.new do |node|\r\n    # Create a new environment (you could also use a different :let block or :before block)\r\n    env = Chef::Environment.new\r\n    env.name 'staging'\r\n\r\n    # Stub the node to return this environment\r\n    node.stub(:chef_environment).and_return(env.name)\r\n\r\n    # Stub any calls to Environment.load to return this environment\r\n    Chef::Environment.stub(:load).and_return(env)\r\n  end.converge('cookbook::recipe')\r\nend\r\n```\r\n\r\n**There is probably a better/easier way to do this. If you have a better solution, please open an issue or Pull Request so we can make this less painful :)**\r\n\r\n\r\nTesting LWRPs\r\n-------------\r\n**WARNING** Cookbooks with dashes (hyphens) are difficult to test with ChefSpec because of how Chef classifies objects. We recommend naming cookbooks with underscores (`_`) instead of dashes (`-`).\r\n\r\nChefSpec overrides all providers to take no action (otherwise it would actually converge your system). This means that the steps inside your LWRP are not actually executed. If an LWRP performs actions, those actions are never executed or added to the resource collection.\r\n\r\nIn order to run the actions exposed by your LWRP, you have to explicitly tell the `Runner` to step into it:\r\n\r\n```ruby\r\nrequire 'chefspec'\r\n\r\ndescribe 'foo::default' do\r\n  let(:chef_run) { ChefSpec::Runner.new(step_into: ['my_lwrp']).converge('foo::default') }\r\n\r\n  it 'installs the foo package through my_lwrp' do\r\n    expect(chef_run).to install_package('foo')\r\n  end\r\nend\r\n```\r\n\r\n**NOTE:** If your cookbook exposes LWRPs, it is highly recommended you also create a `libraries/matchers.rb` file as outlined below in the \"Packaging Custom Matchers\" section. **You should never `step_into` an LWRP unless you are testing it. Never `step_into` an LWRP from another cookbook!**\r\n\r\n\r\nPackaging Custom Matchers\r\n-------------------------\r\nChefSpec exposes the ability for cookbook authors to package custom matchers inside a cookbook so that other developers may take advantage of them in testing. This is done by creating a special library file in the cookbook named `matchers.rb`:\r\n\r\n```ruby\r\n# cookbook/libraries/matchers.rb\r\n\r\nif defined?(ChefSpec)\r\n  def my_custom_matcher(resource_name)\r\n    ChefSpec::Matchers::ResourceMatcher.new(resource, action, resource_name)\r\n  end\r\nend\r\n```\r\n\r\n1. The entire contents of this file must be wrapped with the conditional clause checking if `ChefSpec` is defined.\r\n2. Each matcher is actually a top-level method. The above example corresponds to the following RSpec test:\r\n    ```ruby\r\n    expect(chef_run).to my_custom_matcher('...')\r\n    ```\r\n\r\n3. `ChefSpec::Matchers::ResourceMatcher` accepts three parameters:\r\n    1. The name of the resource to find in the resource collection (i.e. the name of the LWRP).\r\n    2. The action that resource should receive.\r\n    3. The value of the name attribute of the resource to find. (This is typically proxied as the value from the matcher definition.)\r\n\r\nChefSpec's built-in `ResourceMatcher` _should_ satisfy most common use cases for packaging a custom matcher with your LWRPs. However, if your cookbook is extending Chef core or is outside of the scope of a traditional \"resource\", you may need to create a custom matcher. For more information on custom matchers in RSpec, please [watch the Railscast on Custom Matchers](http://railscasts.com/episodes/157-rspec-matchers-macros) or look at some of the other custom matchers in ChefSpec's source code.\r\n\r\n#### Example\r\nSuppose I have a cookbook named \"motd\" with a resource/provider \"message\".\r\n\r\n```ruby\r\n# motd/resources/message.rb\r\nactions :write\r\ndefault_action :write\r\n\r\nattribute :message, name_attribute: true\r\n```\r\n\r\n```ruby\r\n# motd/providers/message.rb\r\naction :write do\r\n  # ...\r\nend\r\n```\r\n\r\nChef will dynamically build the `motd_message` LWRP at runtime that can be used in the recipe DSL:\r\n\r\n```ruby\r\nmotd_message 'my message'\r\n```\r\n\r\nYou can package a custom ChefSpec matcher with the motd cookbook by including the following code in `libraries/matchers.rb`:\r\n\r\n```ruby\r\n# motd/libraries/matchers.rb\r\nif defined?(ChefSpec)\r\n  def write_motd_message(message)\r\n    ChefSpec::Matchers::ResourceMatcher.new(:motd_message, :write, message)\r\n  end\r\nend\r\n```\r\n\r\nOther developers can write RSpec tests against your LWRP in their cookbooks:\r\n\r\n```ruby\r\nexpect(chef_run).to write_motd_message('my message')\r\n```\r\n\r\n**Don't forget to include documentation in your cookbook's README noting the custom matcher and it's API!**\r\n\r\n\r\nWriting Custom Matchers\r\n-----------------------\r\nIf you are testing a cookbook that does not package it's LWRP matchers, you can create your own following the same pattern as the \"Packaging Custom Matchers\" section. Simply, create a file at `spec/support/matchers.rb` and add your resource matchers:\r\n\r\n```ruby\r\n# spec/support/matchers.rb\r\ndef my_custom_matcher(resource_name)\r\n  ChefSpec::Matchers::ResourceMatcher.new(:resource, :action, resource_name)\r\nend\r\n```\r\n\r\nThen require this file in your `spec_helper.rb` so the matcher can be used:\r\n\r\n```ruby\r\nrequire_relative 'support/matchers'\r\n```\r\n\r\nPlease use this as a _temporary_ solution. Consider sending a Pull Request to the LWRP author(s) packaging the custom resource matchers (see previous section).\r\n\r\n\r\nExpecting Exceptions\r\n--------------------\r\nIn Chef 11, custom formatters were introduced and ChefSpec uses a custom formatter to suppress Chef Client output. In the event of a convergence failure, ChefSpec will output the error message from the run to help you debug:\r\n\r\n```text\r\n================================================================================\r\nRecipe Compile Error in apt_package/recipes/install.rb\r\n================================================================================\r\n\r\nRuntimeError\r\n------------\r\nRuntimeError\r\n\r\nCookbook Trace:\r\n---------------\r\n  .../apt_package/recipes/install.rb:1:in `from_file'\r\n  .../apt_package/spec/install_spec.rb:4:in `block (2 levels) in <top (required)>'\r\n  .../apt_package/spec/install_spec.rb:7:in `block (2 levels) in <top (required)>'\r\n\r\nRelevant File Content:\r\n----------------------\r\n.../apt_package/recipes/install.rb:\r\n\r\n  1>> raise RuntimeError\r\n  2:\r\n  3:  apt_package 'default_action'\r\n```\r\n\r\nThis output is automatically silenced when using RSpec's `raise_error` matcher:\r\n\r\n```ruby\r\nlet(:chef_run) { ChefSpec::Runner.new.converge('cookbook::recipe') }\r\n\r\nit 'raises an error' do\r\n  expect {\r\n    chef_run\r\n  }.to raise_error\r\nend\r\n```\r\n\r\nYou can also assert that a particular error was raised. If the error matches the given type, the output is suppressed. If not, the test fails and the entire stack trace is presented.\r\n\r\n```ruby\r\nlet(:chef_run) { ChefSpec::Runner.new.converge('cookbook::recipe') }\r\n\r\nit 'raises an error' do\r\n  expect {\r\n    chef_run\r\n  }.to raise_error(RuntimeError)\r\nend\r\n```\r\n\r\nTesting Roles\r\n-------------\r\nEven though ChefSpec is cookbook-centric, you can still converge multiple recipes and roles in a single `ChefSpec::Runner` instance. Given a cookbook \"bacon\" with a default recipe:\r\n\r\n```ruby\r\n# cookbooks/bacon/recipes/default.rb\r\npackage 'foo'\r\n```\r\n\r\nand a default attributes file:\r\n\r\n```ruby\r\n# cookbooks/bacon/attributes/default.rb\r\ndefault['bacon']['temperature'] = 200\r\n```\r\n\r\nand a role \"breakfast\":\r\n\r\n```ruby\r\n# roles/breakfast.rb\r\ndefault_attributes(\r\n  'bacon' => {\r\n    'temperature' => 150 # NOTE: This is different from the default value\r\n  }\r\n)\r\nrun_list([\r\n  'recipe[bacon::default]'\r\n])\r\n```\r\n\r\nYou can test that the role is appropriately applied by telling the `ChefSpec::Runner` to converge on the _role_ instead of a recipe:\r\n\r\n```ruby\r\nlet(:chef_run) { ChefSpec::Runner.new.converge('role[breakfast]') }\r\n```\r\n\r\nAssert that the run_list is properly expanded:\r\n\r\n```ruby\r\nexpect(chef_run).to include_recipe('bacon::default')\r\n```\r\n\r\nAssert that the correct attribute is used:\r\n\r\n```ruby\r\nexpect(chef_run.node['bacon']['temperature']).to eq(150)\r\n```\r\n\r\n**NOTE** If your roles live somewhere outside of the expected path, you must set `RSpec.config.role_path` to point to the directory containing your roles **before** invoking the `#converge` method!\r\n\r\n```ruby\r\nRSpec.configure do |config|\r\n  config.role_path = '/var/my/roles' # global setting\r\nend\r\n\r\n# - OR -\r\n\r\nChefSpec::Runner.new(role_path: '/var/my/roles') # local setting\r\n```\r\n\r\n\r\nFaster Specs\r\n------------\r\nChefSpec aims to provide the easiest and simplest path for new users to write RSpec examples for Chef cookbooks. In doing so, it makes some sacrifices in terms of speed and agility of execution. In other words, ChefSpec favors \"speed to develop\" over \"speed to execute\". Many of these decisions are directly related to the way Chef dynamically loads resources at runtime.\r\n\r\nIf you understand how RSpec works and would like to see some significant speed improvements in your specs, you can use the `ChefSpec::Cacher` module inspired by [Juri Timošin](https://github.com/DracoAter). Just require the cacher module in your spec helper.\r\n\r\n```ruby\r\n# spec_helper.rb\r\nrequire 'chefspec/cacher'\r\n```\r\n\r\nNext, convert all your `let` blocks to `cached`:\r\n\r\n```ruby\r\n# before\r\nlet(:chef_run) { ChefSpec::Runer.new }\r\n\r\n# after\r\ncached(:chef_run) { ChefSpec::Runner.new }\r\n```\r\n\r\nEverything else should work the same. Be advised, as the method name suggests, this will cache the results of your Chef Client Run for the **entire RSpec example**. This makes stubbing more of a challenge, since the node is already converged. For more information, please see [Juri Timošin's blog post on faster specs](http://dracoater.blogspot.com/2013/12/testing-chef-cookbooks-part-25-speeding.html) as well as the discussion in [#275](https://github.com/sethvargo/chefspec/issues/275).\r\n\r\n\r\nMedia & Third-party Tutorials\r\n-----------------------------\r\n- [CustomInk's Testing Chef Cookbooks](http://technology.customink.com/blog/2012/08/03/testing-chef-cookbooks/)\r\n- [Jake Vanderdray's Practical ChefSpec](http://files.meetup.com/1780846/ChefSpec.pdf)\r\n- [Jim Hopp's excellent Test Driven Development for Chef Practitioners](http://www.youtube.com/watch?v=o2e0aZUAVGw)\r\n- [Joshua Timberman's Starting ChefSpec Examples](http://jtimberman.housepub.org/blog/2013/05/09/starting-chefspec-example/)\r\n- [Juri Timošin's post on faster specs](http://dracoater.blogspot.com/2013/12/testing-chef-cookbooks-part-25-speeding.html)\r\n- [Seth Vargo's Chef recipe code coverage](https://sethvargo.com/chef-recipe-code-coverage/)\r\n- [Seth Vargo's TDDing tmux talk](http://www.confreaks.com/videos/2364-mwrc2013-tdding-tmux)\r\n- [Stephen Nelson Smith's Test-Driven Infrastructure with Chef](http://shop.oreilly.com/product/0636920030973.do)\r\n\r\n\r\nDevelopment\r\n-----------\r\n1. Fork the repository from GitHub.\r\n2. Clone your fork to your local machine:\r\n\r\n        $ git clone git@github.com:USER/chefspec.git\r\n\r\n3. Create a git branch\r\n\r\n        $ git checkout -b my_bug_fix\r\n\r\n4. **Write tests**\r\n5. Make your changes/patches/fixes, committing appropriately\r\n6. Run the tests: `bundle exec rake`\r\n7. Push your changes to GitHub\r\n8. Open a Pull Request\r\n\r\nChefSpec is on [Travis CI](http://travis-ci.org/sethvargo/chefspec) which tests against multiple Chef and Ruby versions.\r\n\r\nIf you are contributing, please see the [Contributing Guidelines](https://github.com/sethvargo/chefspec/blob/master/CONTRIBUTING.md) for more information.\r\n\r\n\r\nLicense\r\n-------\r\nMIT - see the accompanying [LICENSE](https://github.com/sethvargo/chefspec/blob/master/LICENSE) file for details.\r\n","google":"UA-12012976-11","note":"Don't delete this file! It's used internally to help with page regeneration."}